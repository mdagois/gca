include "utils.rgbinc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "vblank_interrupt", rom0[$0040]
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TILES_COUNT						equ (384)
BYTES_PER_TILE					equ (16)
TILES_BYTE_SIZE					equ (TILES_COUNT * BYTES_PER_TILE)

TILEMAPS_COUNT					equ (2)
BYTES_PER_TILEMAP				equ (1024)
TILEMAPS_BYTE_SIZE				equ (TILEMAPS_COUNT * BYTES_PER_TILEMAP)

GRAPHICS_DATA_SIZE				equ (TILES_BYTE_SIZE + TILEMAPS_BYTE_SIZE)
GRAPHICS_DATA_ADDRESS_END		equ ($8000)
GRAPHICS_DATA_ADDRESS_START		equ (GRAPHICS_DATA_ADDRESS_END - GRAPHICS_DATA_SIZE)

; load the graphics data from ROM to VRAM
macro LoadGraphicsDataIntoVRAM
	ld de, GRAPHICS_DATA_ADDRESS_START
	ld hl, _VRAM8000
	.load_tile\@
		ld a, [de]
		inc de
		ld [hli], a
		ld a, d
		cp a, high(GRAPHICS_DATA_ADDRESS_END)
		jr nz, .load_tile\@
endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsset _RAM

; input struct
WRAM_PAD_INPUT					rb sizeof_PAD_INPUT

; background scrolling
WRAM_BG_SCX						rb 1
WRAM_BG_SCY						rb 1

; window control
WRAM_WIN_ENABLE_FLAG			rb 1

WRAM_END						rb 0

; sanity checks
WRAM_USAGE						equ (WRAM_END - _RAM)
print "WRAM usage: {d:WRAM_USAGE} bytes\n"
assert WRAM_USAGE <= $2000, "Too many bytes used in WRAM"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "sample", rom0

InitSample:
	; init the WRAM state
	InitPadInput WRAM_PAD_INPUT
	xor a
	ld [WRAM_BG_SCX], a
	ld [WRAM_BG_SCY], a
	ld [WRAM_WIN_ENABLE_FLAG], a

	; init the palette
	ld a, %11100100
	ld [rBGP], a

	LoadGraphicsDataIntoVRAM

	; enable the vblank interrupt
	ld a, IEF_VBLANK
	ld [rIE], a
	ei

	; place the window at the bottom of the LCD
	copy [rWX], 7
	copy [rWY], 120

	; set the graphics parameters and turn back LCD on
	ld a, LCDCF_ON | LCDCF_WIN9C00 | LCDCF_WINON | LCDCF_BG8800 | LCDCF_BG9800 | LCDCF_BGON
	ld [rLCDC], a

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UpdateSample:
	halt

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; vblank
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; set the background position
	copy [rSCX], [WRAM_BG_SCX]
	copy [rSCY], [WRAM_BG_SCY]

	; toggle the window on/off
	ldh a, [rLCDC]
	and a, ~LCDCF_WINON
	ld hl, WRAM_WIN_ENABLE_FLAG
	or a, [hl]
	ldh [rLCDC], a

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; logic
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	UpdatePadInput WRAM_PAD_INPUT

	; dpad check
	TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_LEFT
	jr nz, .left_checked
		ld hl, WRAM_BG_SCX
		dec [hl]
	.left_checked

	TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_RIGHT
	jr nz, .right_checked
		ld hl, WRAM_BG_SCX
		inc [hl]
	.right_checked

	TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_UP
	jr nz, .up_checked
		ld hl, WRAM_BG_SCY
		dec [hl]
	.up_checked

	TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_DOWN
	jr nz, .down_checked
		ld hl, WRAM_BG_SCY
		inc [hl]
	.down_checked

	; window toggle
	TestPadInput_HeldAll WRAM_PAD_INPUT, PADF_A
	jr nz, .window_toggle_done
		ld a, [WRAM_WIN_ENABLE_FLAG]
		cpl
		and a, LCDCF_WINON
		ld [WRAM_WIN_ENABLE_FLAG], a
	.window_toggle_done

	ret

export InitSample, UpdateSample

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "graphics_data", rom0[GRAPHICS_DATA_ADDRESS_START]
incbin "tileset.chr"
incbin "background.tlm"
incbin "window.tlm"

