include "utils.rgbinc"

;TODO Consolidate code for sending packets
;TODO GUI
;TODO Connection check at the start
;TODO Error management
;TODO Error test
;TODO Cleanup
;TODO Break support

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interrupts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "vblank_interrupt", rom0[$0040]
	push af
	ld a, 1
	ld [WRAM_IS_VBLANK], a
	pop af
	reti

section "timer_interrupt", rom0[$0050]
	jp TimerInterrupt

section "serial_interrupt", rom0[$0058]
	jp SerialInterrupt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Timer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "timer", rom0

StartTimer:
	ld a, 256 - 5
	ld [rTMA], a
	ld [rTIMA], a
	ld [rDIV], a
	copy [rTAC], TACF_START | TACF_16KHZ
	ret

StopTimer:
	copy [rTAC], TACF_STOP
	ret

TimerInterrupt:
	PushAllRegisters

	call StopTimer
	call SendPacketByte

	PopAllRegisters
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Serial
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "serial", rom0

SerialInterrupt:
	PushAllRegisters
	copy [WRAM_PRINT_STATE + PRINT_STATE_ACK], [WRAM_PRINT_STATE + PRINT_STATE_STATUS]
	copy [WRAM_PRINT_STATE + PRINT_STATE_STATUS], [rSB]
	call StartTimer
	PopAllRegisters
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Protocol
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRINTER_STATUS_BIT_LOW_BATTERY		equ (7)
PRINTER_STATUS_BIT_OTHER_ERROR		equ (6)
PRINTER_STATUS_BIT_PAPER_JAM		equ (5)
PRINTER_STATUS_BIT_PACKET_ERROR		equ (4)
PRINTER_STATUS_BIT_READY_TO_PRINT	equ (3)
PRINTER_STATUS_BIT_DATA_FULL		equ (2)
PRINTER_STATUS_BIT_PRINTING			equ (1)
PRINTER_STATUS_BIT_CHECKSUM_ERROR	equ (0)

PACKET_MAGIC_0						equ ($88)
PACKET_MAGIC_1						equ ($33)

PACKET_TYPE_INIT					equ ($01)
PACKET_TYPE_PRINT					equ ($02)
PACKET_TYPE_DATA					equ ($04)
PACKET_TYPE_BREAK					equ ($08)
PACKET_TYPE_STATUS					equ ($0F)

PACKET_COMPRESSION_OFF				equ ($00)
PACKET_COMPRESSION_ON				equ ($01)

rsreset
COMMAND_TYPE_INIT					rb 1
COMMAND_TYPE_PRINT					rb 1
COMMAND_TYPE_DATA					rb 1
COMMAND_TYPE_DATA_END				rb 1
COMMAND_TYPE_BREAK					rb 1
COMMAND_TYPE_STATUS					rb 1
COMMAND_TYPE_CLEANUP				rb 1
COMMAND_TYPES_COUNT					rb 0

rsreset
PRINT_STATE_COMMAND_TYPE			rb 1

PRINT_STATE_DATA_POINTER			rb 2
PRINT_STATE_DATA_END				rb 2

PRINT_STATE_ACK						rb 1
PRINT_STATE_STATUS					rb 1

sizeof_PRINT_STATE					rb 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

macro FixedPacket
db PACKET_MAGIC_0, PACKET_MAGIC_1, \1, PACKET_COMPRESSION_OFF, $00, $00, \1, $00, $00, $00
endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "protocol", rom0

;;;;;;;;;;;;;;;;;;;;
; print packet
;;;;;;;;;;;;;;;;;;;;

PACKET_PRINT_PAYLOAD_SIZE			equ ($0004)
PACKET_PRINT_SHEET_COUNT			equ ($01)
PACKET_PRINT_FEEDS					equ ($14)
PACKET_PRINT_PALETTE				equ ($1B)
PACKET_PRINT_DENSITY				equ ($40)
PACKET_PRINT_CHECKSUM				equ (PACKET_TYPE_PRINT + PACKET_PRINT_PAYLOAD_SIZE + PACKET_PRINT_SHEET_COUNT + PACKET_PRINT_FEEDS + PACKET_PRINT_PALETTE + PACKET_PRINT_DENSITY)

packet_print:
db PACKET_MAGIC_0, PACKET_MAGIC_1
db PACKET_TYPE_PRINT, PACKET_COMPRESSION_OFF
dw PACKET_PRINT_PAYLOAD_SIZE
db PACKET_PRINT_SHEET_COUNT
db PACKET_PRINT_FEEDS
db PACKET_PRINT_PALETTE
db PACKET_PRINT_DENSITY
dw PACKET_PRINT_CHECKSUM
db $00, $00
packet_print_end:

;;;;;;;;;;;;;;;;;;;;
; data packets
;;;;;;;;;;;;;;;;;;;;

PACKET_DATA_PAYLOAD_SIZE 				equ (640)
PACKET_DATA_BYTE_OVERHEAD				equ (10)
PACKET_DATA_SIZE						equ (PACKET_DATA_PAYLOAD_SIZE + PACKET_DATA_BYTE_OVERHEAD)

DATA_PACKET_NUMBER = 0
rept 9

packet_data_{d:DATA_PACKET_NUMBER}:
incbin "print_data.pkt", DATA_PACKET_NUMBER * PACKET_DATA_SIZE, PACKET_DATA_SIZE
packet_data_{d:DATA_PACKET_NUMBER}_end:

DATA_PACKET_NUMBER = DATA_PACKET_NUMBER + 1
endr

;;;;;;;;;;;;;;;;;;;;
; fixed packets
;;;;;;;;;;;;;;;;;;;;

packet_init:
	FixedPacket PACKET_TYPE_INIT
packet_init_end:

packet_data_end:
	FixedPacket PACKET_TYPE_DATA
packet_data_end_end:

packet_break:
	FixedPacket PACKET_TYPE_BREAK
packet_break_end:

packet_status:
	FixedPacket PACKET_TYPE_STATUS
packet_status_end:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; set the parameters of the next packet to be sent 
; \1 = command type, \2 = data start, \3 = data end
macro PrepareNextPacket
	copy [WRAM_PRINT_STATE + PRINT_STATE_COMMAND_TYPE], \1

	ld hl, \2
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER, hl
	ld hl, \3
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_END, hl
endm

; perform tasks common to all packets
macro SendPacketByte_Common
	; send next byte
	load16 hl, WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER
	copy [rSB], [hl]
	copy [rSC], SCF_START | SCF_SOURCE

	; update data pointer
	inc hl
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER, hl

	; return if the end condition is not met
	load16 de, WRAM_PRINT_STATE + PRINT_STATE_DATA_END
	ld a, e
	cp a, l
	ret nz
	ld a, h
	cp a, d
	ret nz
endm

SendPacketByte_Init:
	SendPacketByte_Common
	PrepareNextPacket COMMAND_TYPE_DATA, packet_data_0, packet_data_0_end
	ret

SendPacketByte_Print:
	SendPacketByte_Common
	PrepareNextPacket COMMAND_TYPE_STATUS, packet_status, packet_status_end
	ret

SendPacketByte_Data:
	SendPacketByte_Common

	load16 de, WRAM_PRINT_STATE + PRINT_STATE_DATA_END
	ld a, e
	cp a, low(packet_data_8_end)
	jr nz, .has_more_data_packets
	ld a, h
	cp a, high(packet_data_8_end)
	jr nz, .has_more_data_packets

	; prepare to send the "data end" packet as all data packets are sent
	PrepareNextPacket COMMAND_TYPE_DATA_END, packet_data_end, packet_data_end_end
	ret

	.has_more_data_packets
	; prepare to send the next data packet
	; all that is required is to update the data end pointer
	; the rest of the print state is already set up
	load16 hl, WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER
	ld de, PACKET_DATA_SIZE
	add hl, de
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_END, hl

	ret

SendPacketByte_DataEnd:
	SendPacketByte_Common
	PrepareNextPacket COMMAND_TYPE_PRINT, packet_print, packet_print_end
	ret

SendPacketByte_Break:
	ret

SendPacketByte_Status:
	SendPacketByte_Common
	PrepareNextPacket COMMAND_TYPE_CLEANUP, $0000, $0000
	ret

SendPacketByte_Cleanup:
	;ld a, [WRAM_PRINT_STATE + PRINT_STATE_FLAGS]

	;TODO check $FF $FF -> error #02
	;TODO check low battery -> error #01
	;TODO check paper jam -> error #03
	;TODO check other error -> error #04
	;TODO check printing -> if 1, return to status, otherwise, cleanup

	ld hl, WRAM_PRINT_STARTED
	res 0, [hl]

	ret

CommandFunctionTable:
	dw SendPacketByte_Init
	dw SendPacketByte_Print
	dw SendPacketByte_Data
	dw SendPacketByte_DataEnd
	dw SendPacketByte_Break
	dw SendPacketByte_Status
	dw SendPacketByte_Cleanup

SendPacketByte:
	CallFunctionFromTable CommandFunctionTable, [WRAM_PRINT_STATE + PRINT_STATE_COMMAND_TYPE]
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Memory
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsset _RAM

WRAM_IS_VBLANK					rb 1
WRAM_PRINT_STARTED				rb 1
WRAM_PAD_INPUT					rb sizeof_PAD_INPUT
WRAM_PRINT_STATE				rb sizeof_PRINT_STATE

WRAM_END						rb 0

; sanity checks
WRAM_USAGE						equ (WRAM_END - _RAM)
print "WRAM usage: {d:WRAM_USAGE} bytes\n"
assert WRAM_USAGE <= $2000, "Too many bytes used in WRAM"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "sample", rom0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

InitSample:
	; init the WRAM state
	ClearMemory _RAM, WRAM_END
	InitPadInput WRAM_PAD_INPUT

	; enable interrupts
	copy [rIE], IEF_VBLANK | IEF_TIMER | IEF_SERIAL
	ei

	; init graphics
	copy [rBGP], %11100100

	; set the graphics parameters and turn back LCD on
	copy [rLCDC], LCDCF_ON | LCDCF_BG8800 | LCDCF_BG9800 | LCDCF_BGON

	call StopTimer
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UpdateSample:
	ld hl, WRAM_IS_VBLANK
	xor a
	.wait_vblank
		halt
		cp a, [hl]
		jr z, .wait_vblank
		ld [hl], a

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	UpdatePadInput WRAM_PAD_INPUT

	; only accept input when no printing is occurring
	ld a, [WRAM_PRINT_STARTED]
	bit 0, a
	jr nz, .accept_input
		TestPadInput_Released WRAM_PAD_INPUT, PADF_A
		jr nz, .start_printing
			; raise flag to block input while printing
			ld hl, WRAM_PRINT_STARTED
			set 0, [hl]

			; start the packet transfer sequence
			PrepareNextPacket COMMAND_TYPE_INIT, packet_init, packet_init_end
			call StartTimer
		.start_printing
	.accept_input

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

export InitSample, UpdateSample

