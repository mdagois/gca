include "utils.rgbinc"

;TODO GUI
;TODO Connection check at the start
;TODO Error test
;TODO Break support

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interrupts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; vblank
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "vblank_interrupt", rom0[$0040]
	push af
	ld a, 1
	ld [WRAM_IS_VBLANK], a
	pop af
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Timer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "timer_interrupt", rom0[$0050]
	jp TimerInterrupt

section "timer", rom0

macro StartTimer
	ld a, 256 - 5
	ld [rTMA], a
	ld [rTIMA], a
	ld [rDIV], a
	copy [rTAC], TACF_START | TACF_16KHZ
endm

macro StopTimer
	copy [rTAC], TACF_STOP
endm

TimerInterrupt:
	PushAllRegisters

	StopTimer
	call SendPacketByte

	PopAllRegisters
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Serial
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "serial_interrupt", rom0[$0058]
	jp SerialInterrupt

section "serial", rom0

SerialInterrupt:
	PushAllRegisters

	; BEWARE
	; These instructions are only meaningful on the last byte of each packet.
	; However, it is convenient to just execute the instructions each time a byte is received
	; as trying to detect the last byte of a packet is more work.
	; The values of PRINT_STATE_ACK and PRINT_STATE_STATUS should only be used between packets.
	copy [WRAM_PRINT_STATE + PRINT_STATE_ACK], [WRAM_PRINT_STATE + PRINT_STATE_STATUS]
	copy [WRAM_PRINT_STATE + PRINT_STATE_STATUS], [rSB]

	StartTimer

	PopAllRegisters
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Protocol
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; printer flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRINTER_STATUS_BIT_LOW_BATTERY		equ (7)
PRINTER_STATUS_BIT_OTHER_ERROR		equ (6)
PRINTER_STATUS_BIT_PAPER_JAM		equ (5)
PRINTER_STATUS_BIT_PACKET_ERROR		equ (4)
PRINTER_STATUS_BIT_READY_TO_PRINT	equ (3)
PRINTER_STATUS_BIT_DATA_FULL		equ (2)
PRINTER_STATUS_BIT_PRINTING			equ (1)
PRINTER_STATUS_BIT_CHECKSUM_ERROR	equ (0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; packet constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PACKET_MAGIC_0						equ ($88)
PACKET_MAGIC_1						equ ($33)

PACKET_TYPE_INIT					equ ($01)
PACKET_TYPE_PRINT					equ ($02)
PACKET_TYPE_DATA					equ ($04)
PACKET_TYPE_BREAK					equ ($08)
PACKET_TYPE_STATUS					equ ($0F)

PACKET_COMPRESSION_OFF				equ ($00)
PACKET_COMPRESSION_ON				equ ($01)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; result codes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsreset
RESULT_SUCCESS						rb 1
RESULT_ERROR_01						rb 1
RESULT_ERROR_02						rb 1
RESULT_ERROR_03						rb 1
RESULT_ERROR_04						rb 1
RESULTS_COUNT						rb 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; print state
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsreset
PRINT_STATE_SEND_FUNCTION_ADDRESS	rb 2

PRINT_STATE_DATA_POINTER			rb 2
PRINT_STATE_DATA_END				rb 2

PRINT_STATE_ACK						rb 1
PRINT_STATE_STATUS					rb 1

PRINT_STATE_RESULT					rb 1

sizeof_PRINT_STATE					rb 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; packet definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "protocol", rom0

;;;;;;;;;;;;;;;;;;;;
; fixed packets
;;;;;;;;;;;;;;;;;;;;

; create a simple packet definition with no payload
; \1 = packet type
macro FixedPacket
db PACKET_MAGIC_0, PACKET_MAGIC_1, \1, PACKET_COMPRESSION_OFF, $00, $00, \1, $00, $00, $00
endm

packet_init:
	FixedPacket PACKET_TYPE_INIT
packet_init_end:

packet_data_end:
	FixedPacket PACKET_TYPE_DATA
packet_data_end_end:

packet_break:
	FixedPacket PACKET_TYPE_BREAK
packet_break_end:

packet_status:
	FixedPacket PACKET_TYPE_STATUS
packet_status_end:

;;;;;;;;;;;;;;;;;;;;
; print packet
;;;;;;;;;;;;;;;;;;;;

PACKET_PRINT_PAYLOAD_SIZE			equ ($0004)
PACKET_PRINT_SHEET_COUNT			equ ($01)
PACKET_PRINT_FEEDS					equ ($14)
PACKET_PRINT_PALETTE				equ ($1B)
PACKET_PRINT_DENSITY				equ ($40)
PACKET_PRINT_CHECKSUM				equ (PACKET_TYPE_PRINT + PACKET_PRINT_PAYLOAD_SIZE + PACKET_PRINT_SHEET_COUNT + PACKET_PRINT_FEEDS + PACKET_PRINT_PALETTE + PACKET_PRINT_DENSITY)

packet_print:
db PACKET_MAGIC_0, PACKET_MAGIC_1
db PACKET_TYPE_PRINT, PACKET_COMPRESSION_OFF
dw PACKET_PRINT_PAYLOAD_SIZE
db PACKET_PRINT_SHEET_COUNT
db PACKET_PRINT_FEEDS
db PACKET_PRINT_PALETTE
db PACKET_PRINT_DENSITY
dw PACKET_PRINT_CHECKSUM
db $00, $00
packet_print_end:

;;;;;;;;;;;;;;;;;;;;
; data packets
;;;;;;;;;;;;;;;;;;;;

PACKET_DATA_PAYLOAD_SIZE 				equ (640)
PACKET_DATA_BYTE_OVERHEAD				equ (10) ; fields that are not part of the payload
PACKET_DATA_SIZE						equ (PACKET_DATA_PAYLOAD_SIZE + PACKET_DATA_BYTE_OVERHEAD)

; data packets are defined in a single file, but imported separately into their own labels
DATA_PACKET_NUMBER = 0
rept 9

packet_data_{d:DATA_PACKET_NUMBER}:
incbin "print_data.pkt", DATA_PACKET_NUMBER * PACKET_DATA_SIZE, PACKET_DATA_SIZE
packet_data_{d:DATA_PACKET_NUMBER}_end:

DATA_PACKET_NUMBER = DATA_PACKET_NUMBER + 1
endr

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; send functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; set the parameters of the next packet to be sent 
; \1 = send function address, \2 = data start, \3 = data end
macro PrepareNextPacket
	ld hl, \1
	store16 WRAM_PRINT_STATE + PRINT_STATE_SEND_FUNCTION_ADDRESS, hl
	ld hl, \2
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER, hl
	ld hl, \3
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_END, hl
endm

; perform tasks common to all packets
macro SendPacketByte_Common
	; send a byte
	load16 hl, WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER
	copy [rSB], [hl]
	copy [rSC], SCF_START | SCF_SOURCE

	; update the data pointer to point to the next byte to send
	inc hl
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER, hl

	; check whether all the data for the packet has been sent
	; and return if that is not the case
	load16 de, WRAM_PRINT_STATE + PRINT_STATE_DATA_END
	ld a, e
	cp a, l
	ret nz
	ld a, h
	cp a, d
	ret nz

	; all the packet data has been sent
endm

SendPacketByte_Init:
	SendPacketByte_Common
	PrepareNextPacket SendPacketByte_Data, packet_data_0, packet_data_0_end
	ret

SendPacketByte_Print:
	SendPacketByte_Common
	PrepareNextPacket SendPacketByte_Status, packet_status, packet_status_end
	ret

SendPacketByte_Data:
	SendPacketByte_Common

	; check whether the last data packet was sent
	load16 de, WRAM_PRINT_STATE + PRINT_STATE_DATA_END
	ld a, e
	cp a, low(packet_data_8_end)
	jr nz, .has_more_data_packets
	ld a, h
	cp a, high(packet_data_8_end)
	jr nz, .has_more_data_packets

	; the last data packet was sent, so prepare to send the "data end" packet
	PrepareNextPacket SendPacketByte_DataEnd, packet_data_end, packet_data_end_end
	ret

	.has_more_data_packets
	; there are more data packet to send, so prepare to send the next data packet
	; all that is required is to update the data end pointer
	; the rest of the print state is already set up
	load16 hl, WRAM_PRINT_STATE + PRINT_STATE_DATA_POINTER
	ld de, PACKET_DATA_SIZE
	add hl, de
	store16 WRAM_PRINT_STATE + PRINT_STATE_DATA_END, hl

	ret

SendPacketByte_DataEnd:
	SendPacketByte_Common
	PrepareNextPacket SendPacketByte_Print, packet_print, packet_print_end
	ret

SendPacketByte_Break:
	ret

SendPacketByte_Status:
	SendPacketByte_Common
	PrepareNextPacket SendPacketByte_Cleanup, $0000, $0000
	ret

SendPacketByte_Cleanup:
	; assume success (overwrite in case of error)
	copy [WRAM_PRINT_STATE + PRINT_STATE_RESULT], RESULT_SUCCESS

	.check_not_connected
		ld a, [WRAM_PRINT_STATE + PRINT_STATE_ACK]
		cp a, $FF
		jr nz, .connected
		ld a, [WRAM_PRINT_STATE + PRINT_STATE_STATUS]
		cp a, $FF
		jr nz, .connected

		; not connected
		copy [WRAM_PRINT_STATE + PRINT_STATE_RESULT], RESULT_ERROR_02
		jr .done

	.connected

	ld a, [WRAM_PRINT_STATE + PRINT_STATE_STATUS]

	.check_low_battery
		bit PRINTER_STATUS_BIT_LOW_BATTERY, a
		jr z, .low_battery
			; low battery
			copy [WRAM_PRINT_STATE + PRINT_STATE_RESULT], RESULT_ERROR_01
			jr .done
		.low_battery

	.check_paper_jam
		bit PRINTER_STATUS_BIT_PAPER_JAM, a
		jr z, .paper_jam
			; paper jam
			copy [WRAM_PRINT_STATE + PRINT_STATE_RESULT], RESULT_ERROR_03
			jr .done
		.paper_jam

	.check_other_error ; catch all
		and a, (1 << PRINTER_STATUS_BIT_CHECKSUM_ERROR) | (1 << PRINTER_STATUS_BIT_PACKET_ERROR) | (1 << PRINTER_STATUS_BIT_OTHER_ERROR)
		jr z, .other_error
			; other error
			copy [WRAM_PRINT_STATE + PRINT_STATE_RESULT], RESULT_ERROR_04
			jr .done
		.other_error

	; no error, check whether printing is over
	ld a, [WRAM_PRINT_STATE + PRINT_STATE_STATUS]
	bit PRINTER_STATUS_BIT_PRINTING, a
	jr z, .done

	; printing not over, send another status packet
	PrepareNextPacket SendPacketByte_Status, packet_status, packet_status_end
	StartTimer
	ret

	; printing is done
	.done
	ld hl, WRAM_PRINT_IN_PROGRESS
	res 0, [hl]
	ret

SendPacketByte:
	load16 hl, WRAM_PRINT_STATE + PRINT_STATE_SEND_FUNCTION_ADDRESS
	jp hl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Memory
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsset _RAM

WRAM_IS_VBLANK					rb 1
WRAM_PRINT_IN_PROGRESS			rb 1
WRAM_PAD_INPUT					rb sizeof_PAD_INPUT
WRAM_PRINT_STATE				rb sizeof_PRINT_STATE

WRAM_END						rb 0

; sanity checks
WRAM_USAGE						equ (WRAM_END - _RAM)
print "WRAM usage: {d:WRAM_USAGE} bytes\n"
assert WRAM_USAGE <= $2000, "Too many bytes used in WRAM"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "sample", rom0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

InitSample:
	; init the WRAM state
	ClearMemory _RAM, WRAM_END
	InitPadInput WRAM_PAD_INPUT

	; enable interrupts
	copy [rIE], IEF_VBLANK | IEF_TIMER | IEF_SERIAL
	ei

	; init graphics
	copy [rBGP], %11100100

	; set the graphics parameters and turn back LCD on
	copy [rLCDC], LCDCF_ON | LCDCF_BG8800 | LCDCF_BG9800 | LCDCF_BGON

	StopTimer
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UpdateSample:
	ld hl, WRAM_IS_VBLANK
	xor a
	.wait_vblank
		halt
		cp a, [hl]
		jr z, .wait_vblank
		ld [hl], a

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	UpdatePadInput WRAM_PAD_INPUT

	; only accept input when no printing is occurring
	ld a, [WRAM_PRINT_IN_PROGRESS]
	bit 0, a
	jr nz, .accept_input
		TestPadInput_Released WRAM_PAD_INPUT, PADF_A
		jr nz, .start_printing
			; raise flag to block input while printing
			ld hl, WRAM_PRINT_IN_PROGRESS
			set 0, [hl]

			; start the packet transfer sequence
			PrepareNextPacket SendPacketByte_Init, packet_init, packet_init_end
			StartTimer
		.start_printing
	.accept_input

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

export InitSample, UpdateSample

