include "utils.rgbinc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OAM_OFFSET_X					equ (8)
OAM_OFFSET_Y					equ (16)

COIN_SPRITE_Y					equ (OAM_OFFSET_Y + 64)
COIN_SPRITE_MIN_X				equ (OAM_OFFSET_X + 24)
COIN_SPRITE_MAX_X				equ (COIN_SPRITE_MIN_X + 24)

COIN_SPRITE_LEFT				equ (_OAMRAM + sizeof_OAM_ATTRS * 0)
COIN_SPRITE_RIGHT				equ (_OAMRAM + sizeof_OAM_ATTRS * 1)

COIN_PALETTE					equ (0)

COIN_ANIM_UPDATE_PERIOD			equ (10)
COIN_X_UPDATE_PERIOD			equ (5)
COIN_FRAME_COUNT				equ (6)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsset _RAM

WRAM_TOGGLE_PRIORITY			rb 1

WRAM_COIN_FRAME_UPDATE_COUNTER	rb 1
WRAM_COIN_FRAME					rb 1
WRAM_COIN_X_UPDATE_COUNTER		rb 1
WRAM_COIN_X						rb 1
WRAM_COIN_MOVE					rb 1

WRAM_END						rb 0

; sanity checks
WRAM_USAGE						equ (WRAM_END - _RAM)
print "WRAM usage: {d:WRAM_USAGE} bytes\n"
assert WRAM_USAGE <= $2000, "Too many bytes used in WRAM"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "vblank_interrupt", rom0[$0040]
	reti

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; \1 = destination address
; \2 = source region start address
; \3 = source region end address
HdmaCopy: macro
	assert \3 > \2, "The source region's end address must be superior to its start address"
	assert (\3 - \2) % 16 == 0, "The source region size must be a multiple of 16"
	copy [rHDMA1], high(\2)
	copy [rHDMA2], low(\2)
	copy [rHDMA3], high(\1)
	copy [rHDMA4], low(\1)
	copy [rHDMA5], HDMA5F_MODE_GP | (((\3 - \2) / 16) - 1)
endm

section "graphics", rom0

palette_data:
incbin "ship.pal"
palette_data_end:

tileset:
incbin "ship.chr"
tileset_end:

tilemap_indices:
incbin "ship.idx"
tilemap_indices_end:

tilemap_parameters:
incbin "ship.prm"
tilemap_parameters_end:

coins:
incbin "coins.chr"
coins_end:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "sample", rom0

InitSample:
	; set wram variables
	copy [WRAM_TOGGLE_PRIORITY], 0
	copy [WRAM_COIN_FRAME_UPDATE_COUNTER], COIN_ANIM_UPDATE_PERIOD
	copy [WRAM_COIN_X_UPDATE_COUNTER], COIN_X_UPDATE_PERIOD
	copy [WRAM_COIN_FRAME], 0
	copy [WRAM_COIN_X], COIN_SPRITE_MIN_X
	copy [WRAM_COIN_MOVE], 1

	; copy all the bg palettes
	copy [rBCPS], 0 | BCPSF_AUTOINC
	ld hl, palette_data
	ld c, palette_data_end - palette_data
	.palette_copy
		copy [rBCPD], [hli]
		dec c
		jr nz, .palette_copy

	; copy the tileset
	copy [rVBK], 0
	HdmaCopy _VRAM8000, tileset, tileset_end

	; copy the tile indices into VRAM bank 0
	copy [rVBK], 0
	HdmaCopy _SCRN0, tilemap_indices, tilemap_indices_end

	; copy the tile parameters into VRAM bank 1
	copy [rVBK], 1
	HdmaCopy _SCRN0, tilemap_parameters, tilemap_parameters_end

	; copy the coins
	copy [rVBK], 1
	HdmaCopy _VRAM8000, coins, coins_end

	; set sprites palettes
	copy [rOCPS], 0 | BCPSF_AUTOINC

		; black
		copy [rOCPD], $00
		copy [rOCPD], $00
		; orange
		copy [rOCPD], $7F
		copy [rOCPD], $02
		; yellow
		copy [rOCPD], $BF
		copy [rOCPD], $1F
		; white
		copy [rOCPD], $FF
		copy [rOCPD], $FF

		; black
		copy [rOCPD], $00
		copy [rOCPD], $00
		; red
		copy [rOCPD], $5C
		copy [rOCPD], $01
		; orange
		copy [rOCPD], $FE
		copy [rOCPD], $09
		; white
		copy [rOCPD], $FF
		copy [rOCPD], $FF

	; clear unused palettes
	ld c, 24
	.obj_palette_clear
		copy [rOCPD], $00
		copy [rOCPD], $80
		dec c
		jr nz, .obj_palette_clear

	; clear the OAM
	InitOAM

	; set coin parameters that are fixed
	copy [COIN_SPRITE_LEFT + OAMA_Y], COIN_SPRITE_Y
	copy [COIN_SPRITE_LEFT + OAMA_FLAGS], COIN_PALETTE | OAMF_BANK1
	copy [COIN_SPRITE_RIGHT + OAMA_Y], COIN_SPRITE_Y
	copy [COIN_SPRITE_RIGHT + OAMA_FLAGS], COIN_PALETTE | OAMF_BANK1

	; enable interrupts
	copy [rIE], IEF_VBLANK
	ei

	; set LCD parameters
	copy [rLCDC], LCDCF_ON | LCDCF_BG8000 | LCDCF_BG9800 | LCDCF_OBJ16 | LCDCF_OBJON | LCDCF_BGON

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UpdateSample:
	halt

	; update the OAM parameters
	ld a, [WRAM_COIN_FRAME]
	sla a
	sla a
	ld [COIN_SPRITE_LEFT + OAMA_TILEID], a
	add a, 2
	ld [COIN_SPRITE_RIGHT + OAMA_TILEID], a

	ld a, [WRAM_COIN_X]
	ld [COIN_SPRITE_LEFT + OAMA_X], a
	add a, 8
	ld [COIN_SPRITE_RIGHT + OAMA_X] , a

	ld a, [WRAM_TOGGLE_PRIORITY]
	dec a
	jr nz, .toggle_background_parameters
		copy [WRAM_TOGGLE_PRIORITY], 0

		copy [rVBK], 1

		ld hl, _SCRN0 + 8 * SCRN_VX_B + 5
		ld a, [hl]
		xor a, %10000000
		ld [hl], a

		ld de, 32
		add hl, de
		ld a, [hl]
		xor a, %10000000
		ld [hl], a
	.toggle_background_parameters

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; update the coin position
	ld hl, WRAM_COIN_FRAME_UPDATE_COUNTER
	dec [hl]
	jr nz, .update_frame
		ld [hl], COIN_ANIM_UPDATE_PERIOD
		ld a, [WRAM_COIN_FRAME]
		inc a
		cp a, COIN_FRAME_COUNT
		jr nz, .reset_frame
			xor a
		.reset_frame
		ld [WRAM_COIN_FRAME], a
	.update_frame

	; update the coin animation frame
	ld hl, WRAM_COIN_X_UPDATE_COUNTER
	dec [hl]
	jr nz, .update_x
		ld [hl], COIN_X_UPDATE_PERIOD

		ld a, [WRAM_COIN_MOVE]
		ld b, a

		ld a, [WRAM_COIN_X]
		add a, b
		ld [WRAM_COIN_X], a

		cp a, COIN_SPRITE_MIN_X
		jr nc, .below_min
			copy [WRAM_COIN_MOVE], 1
			copy [WRAM_TOGGLE_PRIORITY], 1
		.below_min

		cp a, COIN_SPRITE_MAX_X
		jr c, .above_max
			copy [WRAM_COIN_MOVE], -1
			copy [WRAM_TOGGLE_PRIORITY], 1
		.above_max
	.update_x

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

export InitSample, UpdateSample

