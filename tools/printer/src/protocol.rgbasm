include "memory.rgbinc"
include "utils.rgbinc"

; TODO
; palette support
; low battery
; handle data full (just debug message)
; timeout
; compression
; break packet (warning message)
; nul packet

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Protocol
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; magic bytes sent at the start of every packet
PRINTER_MAGIC_BYTE_0				equ ($88)
PRINTER_MAGIC_BYTE_1				equ ($33)

; packet types
PRINTER_PACKET_TYPE_INIT			equ ($01)
PRINTER_PACKET_TYPE_PRINT			equ ($02)
PRINTER_PACKET_TYPE_DATA			equ ($04)
PRINTER_PACKET_TYPE_BREAK			equ ($08)
PRINTER_PACKET_TYPE_NUL				equ ($0F)

; compression flag
PRINTER_COMPRESSION_FLAG_OFF		equ (%00000000)
PRINTER_COMPRESSION_FLAG_ON			equ (%00000001)

; ack value
PRINTER_ACK_VALUE					equ ($81)

; status bits
PRINTER_STATUS_BIT_LOW_BATTERY		equ (7)
PRINTER_STATUS_BIT_OTHER_ERROR		equ (6)
PRINTER_STATUS_BIT_PAPER_JAM		equ (5)
PRINTER_STATUS_BIT_PACKET_ERROR		equ (4)
PRINTER_STATUS_BIT_READY_TO_PRINT	equ (3)
PRINTER_STATUS_BIT_DATA_FULL		equ (2)
PRINTER_STATUS_BIT_PRINTING			equ (1)
PRINTER_STATUS_BIT_CHECKSUM_ERROR	equ (0)

; status flags
PRINTER_STATUS_FLAG_LOW_BATTERY		equ (1 << PRINTER_STATUS_BIT_LOW_BATTERY)
PRINTER_STATUS_FLAG_OTHER_ERROR		equ (1 << PRINTER_STATUS_BIT_OTHER_ERROR)
PRINTER_STATUS_FLAG_PAPER_JAM		equ (1 << PRINTER_STATUS_BIT_PAPER_JAM)
PRINTER_STATUS_FLAG_PACKET_ERROR	equ (1 << PRINTER_STATUS_BIT_PACKET_ERROR)
PRINTER_STATUS_FLAG_READY_TO_PRINT	equ (1 << PRINTER_STATUS_BIT_READY_TO_PRINT)
PRINTER_STATUS_FLAG_DATA_FULL		equ (1 << PRINTER_STATUS_BIT_DATA_FULL)
PRINTER_STATUS_FLAG_PRINTING		equ (1 << PRINTER_STATUS_BIT_PRINTING)
PRINTER_STATUS_FLAG_CHECKSUM_ERROR	equ (1 << PRINTER_STATUS_BIT_CHECKSUM_ERROR)

; flags that persist between packets (except init)
PRINTER_STATUS_PERSISTENT_FLAGS		equ (PRINTER_STATUS_FLAG_LOW_BATTERY | PRINTER_STATUS_FLAG_READY_TO_PRINT | PRINTER_STATUS_FLAG_DATA_FULL | PRINTER_STATUS_FLAG_PRINTING)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Byte types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rsreset

BYTE_MAGIC_0				rb 1
BYTE_MAGIC_1				rb 1
BYTE_HEADER_PACKET_TYPE		rb 1
BYTE_HEADER_COMPRESSION		rb 1
BYTE_HEADER_DATA_SIZE_LSB	rb 1
BYTE_HEADER_DATA_SIZE_MSB	rb 1
BYTE_PACKET_DATA			rb 1
BYTE_PACKET_PRINT			rb 1
BYTE_PACKET_CHECKSUM_LSB	rb 1
BYTE_PACKET_CHECKSUM_MSB	rb 1
BYTE_PACKET_ACK				rb 1
BYTE_PACKET_STATUS			rb 1
BYTES_COUNT					rb 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Miscellaneous
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IMAGE_BYTES_PER_VRAM_TRANSFER		equ (16)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "protocol", rom0

ProtocolInitialize::
	copy [vNextByte], BYTE_MAGIC_0

	; get ready to receive the first byte
	reset [rSB]
	copy [rSC], SCF_START
	ret

ProtocolUpdate::
	ret

ProtocolUpdateVblank::
	; check whether printing has started
	ld hl, vStatus
	bit PRINTER_STATUS_BIT_PRINTING, [hl]
	ret z

	; compute the source and destination addresses
	load16 bc, vVramTransferredSize
		; get the source data address into (de)
		ld hl, vImageData
		add hl, bc
		ldr16 de, hl
		; get the destination data address into (hl)
		ld hl, _VRAM
		add hl, bc

	; transfer a fixed amount of bytes from the image data to VRAM
	ld c, IMAGE_BYTES_PER_VRAM_TRANSFER
	.vram_transfer
		ld a, [de]
		ld [hli], a
		inc de
		dec c
	jr nz, .vram_transfer

	; update the size of the image data transferred to VRAM
	load16 hl, vVramTransferredSize
	ld de, IMAGE_BYTES_PER_VRAM_TRANSFER
	add hl, de
	store16 vVramTransferredSize, hl

	; check whether the printing is over
	ld a, [vVramTransferredSize + 0]
	ld b, a
	ld a, [vImageDataSize + 0]
	cp a, b
	ret nz
	ld a, [vVramTransferredSize + 1]
	ld b, a
	ld a, [vImageDataSize + 1]
	cp a, b
	ret nz

	; update the status to indicate that printing is over
	ld hl, vStatus
	res PRINTER_STATUS_BIT_PRINTING, [hl]
	res PRINTER_STATUS_BIT_READY_TO_PRINT, [hl]

	ret

; table of all the byte processing functions
ProcessFunctionTable:
dw ProcessMagicByte0
dw ProcessMagicByte1
dw ProcessHeaderPacketType
dw ProcessHeaderDataCompression
dw ProcessHeaderDataSizeLSB
dw ProcessHeaderDataSizeMSB
dw ProcessPacketData
dw ProcessPacketPrint
dw ProcessPacketChecksumLSB
dw ProcessPacketChecksumMSB
dw ProcessPacketAck
dw ProcessPacketStatus

ProtocolHandlePacketByte::
	CallFunctionFromTable ProcessFunctionTable, vNextByte
	; get ready to receive the next byte
	copy [rSC], SCF_START
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Checksum helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; set the current packet checksum to zero
macro ResetChecksum
	xor a
	ld [vPacketChecksum + 0], a
	ld [vPacketChecksum + 1], a
endm

; add (a) to the current packet checksum
; preserve value in (a)
macro UpdateChecksum
	push af

	ld d, 0
	ld e, a
	load16 hl, vPacketChecksum
	add hl, de
	store16 vPacketChecksum, hl

	pop af
endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Magic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessMagicByte0:
	debug "[PKT] ===================="
	debug "  magic LSB"
	ld a, [rSB]
	cp a, PRINTER_MAGIC_BYTE_0
	jr z, .ok
		debug "  [ERROR] magic LSB mismatch"
	.ok

	; clean error flags (but keep the other ones)
	ld a, [vStatus]
	and a, PRINTER_STATUS_PERSISTENT_FLAGS
	ld [vStatus], a

	reset [rSB]
	reset [vStatusDelayed]
	copy [vNextByte], BYTE_MAGIC_1
	ret

ProcessMagicByte1:
	debug "  magic MSB"
	ld a, [rSB]
	cp a, PRINTER_MAGIC_BYTE_1
	jr z, .ok
		debug "  [ERROR] magic MSB mismatch"
	.ok

	reset [rSB]
	copy [vNextByte], BYTE_HEADER_PACKET_TYPE
	ResetChecksum
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Packet type (header)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessHeaderPacketType:
	ld a, [rSB]
	UpdateChecksum
	copy [vPacketType], a

	; perform packet-specific operations
	cp a, PRINTER_PACKET_TYPE_INIT
	jr nz, .type_init
		debug "  header (type=init)"
		xor a
		ld [vStatus], a
		ld [vImageDataSize + 0], a
		ld [vImageDataSize + 1], a
		jp .packet_type_done
	.type_init
	cp a, PRINTER_PACKET_TYPE_PRINT
	jr nz, .type_print
		debug "  header (type=print)"
		jp .packet_type_done
	.type_print
	cp a, PRINTER_PACKET_TYPE_DATA
	jr nz, .type_data
		debug "  header (type=data)"
		jr .packet_type_done
	.type_data
	cp a, PRINTER_PACKET_TYPE_BREAK
	jr nz, .type_break
		debug "  header (type=break)"
		jr .packet_type_done
	.type_break
	cp a, PRINTER_PACKET_TYPE_NUL
	jr nz, .type_nul
		debug "  header (type=nul)"
		jr .packet_type_done
	.type_nul

	debug "  [ERROR] unknown packet type"
	.packet_type_done

	reset [rSB]
	copy [vNextByte], BYTE_HEADER_COMPRESSION
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data compression (header)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessHeaderDataCompression:
	debug "  header (compression)"
	ld a, [rSB]
	ld [vDataCompression], a
	UpdateChecksum
	reset [rSB]
	copy [vNextByte], BYTE_HEADER_DATA_SIZE_LSB
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data size (header)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessHeaderDataSizeLSB:
	debug "  header (size LSB)"
	ld a, [rSB]
	ld [vPacketDataSize + 0], a
	UpdateChecksum
	reset [rSB]
	copy [vNextByte], BYTE_HEADER_DATA_SIZE_MSB
	ret

ProcessHeaderDataSizeMSB:
	debug "  header (size MSB)"
	ld a, [rSB]
	ld [vPacketDataSize + 1], a
	UpdateChecksum
	reset [rSB]

	; check whether there is data inside the packet (size > 0)
	ld a, [vPacketDataSize + 0]
	cp a, 0
	jr nz, .has_data
	ld a, [vPacketDataSize + 1]
	cp a, 0
	jr nz, .has_data

	copy [vNextByte], BYTE_PACKET_CHECKSUM_LSB
	ret

	.has_data

	; reset the number of data bytes transferred
	xor a
	ld [vReceivedDataSize + 0], a
	ld [vReceivedDataSize + 1], a

	; check the packet type to determine which type of bytes is coming next
	ld a, [vPacketType]
	cp a, PRINTER_PACKET_TYPE_DATA
	jr nz, .packet_data
		copy [vNextByte], BYTE_PACKET_DATA
		ret
	.packet_data
	cp a, PRINTER_PACKET_TYPE_PRINT
	jr nz, .packet_print
		copy [vNextByte], BYTE_PACKET_PRINT
		ret
	.packet_print

	; only two types of packet have a data section: "data" and "print"
	; assume a data byte when the packet type is unexpected
	; it probably won't work, but logs should help debug
	debug "  [ERROR] unknown data packet"
	copy [vNextByte], BYTE_PACKET_DATA

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessPacketData:
	ld a, [rSB]
	UpdateChecksum
	ld b, a

	; find the next image data byte address and put the received byte into it
	ld hl, vImageData
	load16 de, vImageDataSize
	add hl, de
	ld [hl], b
	inc de
	store16 vImageDataSize, de

	reset [rSB]

	; update the amount of received bytes
	load16 hl, vReceivedDataSize
	inc hl
	store16 vReceivedDataSize, hl

	; check whether all bytes have been received
	ld a, [vPacketDataSize + 0]
	ld b, a
	ld a, [vReceivedDataSize + 0]
	cp a, b
	ret nz
	ld a, [vPacketDataSize + 1]
	ld b, a
	ld a, [vReceivedDataSize + 1]
	cp a, b
	ret nz

	; all the data has been reeived
	; the printer is ready to print
	debug "  data transferred"
	copy [vNextByte], BYTE_PACKET_CHECKSUM_LSB
	ld hl, vStatusDelayed
	set PRINTER_STATUS_BIT_READY_TO_PRINT, [hl]

	; check whether the image data is full and raise flag accordingly
	ld a, [vImageDataSize + 0]
	cp a, low(IMAGE_DATA_MAX_SIZE)
	ret nz
	ld a, [vImageDataSize + 1]
	cp a, high(IMAGE_DATA_MAX_SIZE)
	ret nz
	debug "  data full"
	ld hl, vStatusDelayed
	set PRINTER_STATUS_BIT_DATA_FULL, [hl]
	ret

ProcessPacketPrint:
	debug "  print"
	ld a, [rSB]
	UpdateChecksum

	; find the next parameter data byte address and put the received byte into it
	ld d, 0
	ld hl, vReceivedDataSize
	ld e, [hl]
	ld hl, vPrintParameters
	add hl, de
	ld [hl], a
	inc e
	ld hl, vReceivedDataSize
	ld [hl], e

	reset [rSB]

	; check whether all parameters have been received
	ld a, [vReceivedDataSize]
	cp a, PRINT_PARAMETERS_COUNT
	ret nz

	copy [vNextByte], BYTE_PACKET_CHECKSUM_LSB

	; prepare for printing
	ld hl, vStatusDelayed
	set PRINTER_STATUS_BIT_PRINTING, [hl]
	xor a
	ld [vVramTransferredSize + 0], a
	ld [vVramTransferredSize + 1], a

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Checksum
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessPacketChecksumLSB:
	debug "  checksum LSB"
	ld a, [rSB]

	; validate the checksum LSB
	ld b, a
	ld a, [vPacketChecksum + 0]
	cp a, b
	jr z, .no_error
		debug "  [ERROR] checksum LSB failure"
		ld hl, vStatus
		set PRINTER_STATUS_BIT_CHECKSUM_ERROR, [hl]
	.no_error

	copy [vNextByte], BYTE_PACKET_CHECKSUM_MSB
	reset [rSB]
	ret

ProcessPacketChecksumMSB:
	debug "  checksum MSB"
	ld a, [rSB]

	; validate the checksum MSB
	ld b, a
	ld a, [vPacketChecksum + 1]
	cp a, b
	jr z, .no_error
		debug "  [ERROR] checksum MSB failure"
		ld hl, vStatus
		set PRINTER_STATUS_BIT_CHECKSUM_ERROR, [hl]
	.no_error

	copy [vNextByte], BYTE_PACKET_ACK
	; prepare to send back the ack value
	copy [rSB], PRINTER_ACK_VALUE
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Response
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProcessPacketAck:
	debug "  ack"
	; prepare to send the status
	ld a, [vStatus]
	ld [rSB], a

	; merge the delayed status (reflected in the next packet response)
	ld b, a
	ld a, [vStatusDelayed]
	or a, b
	ld [vStatus], a

	copy [vNextByte], BYTE_PACKET_STATUS
	ret

ProcessPacketStatus:
	debug "  status"
	; the packet is done
	; prepare for the next packet
	reset [rSB]
	copy [vNextByte], BYTE_MAGIC_0
	ret

