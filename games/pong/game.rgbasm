include "data.rgbinc"
include "memory.rgbinc"

export _Game_Initialize, _Game_Update, _Game_UpdateGraphics

section "game", rom0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def REAL_FRACTION_PART	equ (0)
def REAL_INTEGER_PART	equ (1)

; set the 16-bit number at address \1 to value \2
macro Set16
	ld a, low(\2)
	ldh [\1 + REAL_FRACTION_PART], a
	ld a, high(\2)
	ldh [\1 + REAL_INTEGER_PART], a
endm

; perform a 16-bit add for numbers at addresses \1 and \2
; the result is stored back at address \1
macro Add16
	ldh a, [\1 + REAL_FRACTION_PART]
	ld b, a
	ldh a, [\2 + REAL_FRACTION_PART]
	add a, b
	ldh [\1 + REAL_FRACTION_PART], a

	ldh a, [\1 + REAL_INTEGER_PART]
	ld b, a
	ldh a, [\2 + REAL_INTEGER_PART]
	adc a, b
	ldh [\1 + REAL_INTEGER_PART], a
endm

; negate the 16-bit number at address \1
macro Negate16
	ldh a, [\1 + REAL_FRACTION_PART]
	xor a, $FF
	ld l, a
	ldh a, [\1 + REAL_INTEGER_PART]
	xor a, $FF
	ld h, a

	ld d, 0
	ld e, 1
	add hl, de

	ld a, l
	ldh [\1 + REAL_FRACTION_PART], a
	ld a, h
	ldh [\1 + REAL_INTEGER_PART], a
endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def LEFT_INDEX		equ (0)
def RIGHT_INDEX		equ (1)

ResetScore:
	xor a
	ldh [vScore + LEFT_INDEX], a
	ldh [vScore + RIGHT_INDEX], a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def BALL_INITIAL_SPEED		equ (2)
def BALL_MAX_SPEED			equ (6)
def BALL_HIT_COUNTER		equ (5)
def BALL_INITIAL_POS_X		equ (((SCRN_X + OAM_X_OFS) / 2 + 2) << 8)
def BALL_INITIAL_POS_Y		equ (((SCRN_Y + OAM_Y_OFS) / 2 - 2) << 8)
def BALL_INITIAL_DIR_X		equ ($007F)
def BALL_INITIAL_DIR_Y		equ ($0000)

_Game_Initialize:
	call ResetScore

	; set sprite tile IDs
	copy [vBallOam + OAMA_TILEID], TILE_ID_BALL
	ld a, TILE_ID_PADS
	ld [vLeftPadTopOam + OAMA_TILEID], a
	inc a
	ld [vLeftPadBottomOam + OAMA_TILEID], a
	inc a
	ld [vRightPadTopOam + OAMA_TILEID], a
	inc a
	ld [vRightPadBottomOam + OAMA_TILEID], a

	; set ball sprite initial positions
	Set16 vBallX, BALL_INITIAL_POS_X
	Set16 vBallY, BALL_INITIAL_POS_Y

	; set pad fixed position
	ld a, OAM_X_OFS
	ld [vLeftPadTopOam + OAMA_X], a
	ld [vLeftPadBottomOam + OAMA_X], a
	ld a, SCRN_X
	ld [vRightPadTopOam + OAMA_X], a
	ld [vRightPadBottomOam + OAMA_X], a

	; set pad variable positions
	ld a, ((SCRN_Y + OAM_Y_OFS) / 2) - 8
	ldh [vPadsY + LEFT_INDEX], a
	ldh [vPadsY + RIGHT_INDEX], a

	; set initial ball dynamics
	Set16 vBallDirX, BALL_INITIAL_DIR_X
	Set16 vBallDirY, BALL_INITIAL_DIR_Y
	ld a, BALL_INITIAL_SPEED
	ldh [vBallSpeed], a

	; miscellaneous
	ld a, BALL_HIT_COUNTER
	ldh [vBallHitCounter], a

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def SCORE_MAX			equ (9)

def WALL_HEIGHT			equ (8)
def PAD_WIDTH			equ (8)
def PAD_HEIGHT			equ (16)
def BALL_WIDTH			equ (4)
def BALL_HEIGHT			equ (4)

def PAD_MIN_Y			equ (OAM_Y_OFS + WALL_HEIGHT)
def PAD_MAX_Y			equ (SCRN_Y + OAM_Y_OFS - WALL_HEIGHT - PAD_HEIGHT)

def BALL_MIN_Y			equ (OAM_Y_OFS + WALL_HEIGHT)
def BALL_MAX_Y			equ (SCRN_Y + OAM_Y_OFS - WALL_HEIGHT - BALL_HEIGHT)

direction_table_left:
; 22.5 degrees
dw $0031, $FF8A
dw $0031, $FF8A
; 45.0 degrees
dw $005A, $FFA6
dw $005A, $FFA6
dw $005A, $FFA6
; 67.5 degrees
dw $0076, $FFCF
dw $0076, $FFCF
dw $0076, $FFCF
; 90.0 degrees
dw $007F, $0000
dw $007F, $0000
dw $007F, $0000
; 112.5 degrees
dw $0076, $0031
dw $0076, $0031
dw $0076, $0031
; 135.0 degrees
dw $005A, $005A
dw $005A, $005A
dw $005A, $005A
; 157.5 degrees
dw $0031, $0076
dw $0031, $0076
direction_table_left_end:
assert (direction_table_left_end - direction_table_left) / 4 == 19, "There must be 19 directions defined in the table"

direction_table_right:
; 22.5 degrees
dw $FFCF, $FF8A
dw $FFCF, $FF8A
; 45.0 degrees
dw $FFA6, $FFA6
dw $FFA6, $FFA6
dw $FFA6, $FFA6
; 67.5 degrees
dw $FF8A, $FFCF
dw $FF8A, $FFCF
dw $FF8A, $FFCF
; 90.0 degrees
dw $FF81, $0000
dw $FF81, $0000
dw $FF81, $0000
; 112.5 degrees
dw $FF8A, $0031
dw $FF8A, $0031
dw $FF8A, $0031
; 135.0 degrees
dw $FFA6, $005A
dw $FFA6, $005A
dw $FFA6, $005A
; 157.5 degrees
dw $FFCF, $0076
dw $FFCF, $0076
direction_table_right_end:
assert (direction_table_right_end - direction_table_right) == (direction_table_left_end - direction_table_left), "The right direction table size must be the same size as the left direction table"

UpdatePads:
	; move and apply constraint to left pad
	PadInput_TestHeld vPadInput, PADF_UP
	jr nz, .left_up
		ldh a, [vPadsY + LEFT_INDEX]
		dec a
		cp a, PAD_MIN_Y
		jr nc, .left_underflow
			ld a, PAD_MIN_Y
		.left_underflow
		ldh [vPadsY + LEFT_INDEX], a
	.left_up
	PadInput_TestHeld vPadInput, PADF_DOWN
	jr nz, .left_down
		ldh a, [vPadsY + LEFT_INDEX]
		inc a
		cp a, PAD_MAX_Y
		jr c, .left_overflow
			ld a, PAD_MAX_Y
		.left_overflow
		ldh [vPadsY + LEFT_INDEX], a
	.left_down

if def(DEBUG_CONTROL_RIGHT_PAD)
	; move and apply constraint to right pad
	PadInput_TestHeld vPadInput, PADF_UP
	jr nz, .right_up
		ldh a, [vPadsY + RIGHT_INDEX]
		dec a
		cp a, PAD_MIN_Y
		jr nc, .right_underflow
			ld a, PAD_MIN_Y
		.right_underflow
		ldh [vPadsY + RIGHT_INDEX], a
	.right_up
	PadInput_TestHeld vPadInput, PADF_DOWN
	jr nz, .right_down
		ldh a, [vPadsY + RIGHT_INDEX]
		inc a
		cp a, PAD_MAX_Y
		jr c, .right_overflow
			ld a, PAD_MAX_Y
		.right_overflow
		ldh [vPadsY + RIGHT_INDEX], a
	.right_down
endc

	ret

; accelerate the ball each time the hit counter runs out
UpdateBallSpeed:
	; update the counter
	ldh a, [vBallHitCounter]
	dec a
	ldh [vBallHitCounter], a
	ret nz

	; check whether the ball already reached max speed
	ldh a, [vBallSpeed]
	cp a, BALL_MAX_SPEED
	ret z

	; increase the ball speed
	inc a
	ldh [vBallSpeed], a

	; reset the counter
	ld a, BALL_HIT_COUNTER
	ldh [vBallHitCounter], a

	ret

; apply collision constraints of the ball with the walls
HandleBallWallCollision:
	; check for top wall collision
	.check_top_wall
		ldh a, [vBallY + REAL_INTEGER_PART]
		cp a, BALL_MIN_Y
		; jump if no collision
		jr nc, .check_bottom_wall

	; handle the top wall collision
	.handle_top_wall
		; apply constraint
		Set16 vBallY, BALL_MIN_Y << 8
		; reverse Y direction
		Negate16 vBallDirY
		; return early as there cannot be a collision with both walls
		ret

	; check for bottom wall collision
	.check_bottom_wall
		ldh a, [vBallY + REAL_INTEGER_PART]
		cp a, BALL_MAX_Y
		; return if no collision
		ret c

	; handle the bottom wall collision
	.handle_bottom_wall
		; apply constraint
		Set16 vBallY, BALL_MAX_Y << 8
		; reverse Y direction
		Negate16 vBallDirY

	ret

HandleLeftEvents:
	; return early if the ball is not going left
	ldh a, [vBallDirX + REAL_INTEGER_PART]
	bit 7, a
	rcf
	ret z

	; check whether the ball hit the pad
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, OAM_X_OFS + PAD_WIDTH
	jr nz, .left_pad_collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		ld b, a
		ldh a, [vPadsY + LEFT_INDEX]

		; check if ball is too low
		add a, PAD_HEIGHT - 1
		cp a, b
		jr c, .left_pad_collision

		; check if ball is too high
		sub a, (PAD_HEIGHT - 1) + BALL_HEIGHT
		cp a, b
		jr nc, .left_pad_collision

		; NOTE: the ball hit the pad

		; determine the relative position of the ball to the pad
		; a = vBallY - (vPadY - 3)
		ld d, a
		inc d
		ld a, b
		sub a, d

		; get a pointer to the new direction entries
		; hl = direction_table_left + (4 * a)
		add a, a
		add a, a
		ld h, 0
		ld l, a
		ld de, direction_table_left
		add hl, de

		; update the direction
		ld a, [hli]
		ldh [vBallDirX + REAL_FRACTION_PART], a
		ld a, [hli]
		ldh [vBallDirX + REAL_INTEGER_PART], a
		ld a, [hli]
		ldh [vBallDirY + REAL_FRACTION_PART], a
		ld a, [hli]
		ldh [vBallDirY + REAL_INTEGER_PART], a

		; update ball speed
		call UpdateBallSpeed

		scf
		ret
	.left_pad_collision

	; check whether the ball reached the goal
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, OAM_X_OFS - BALL_WIDTH
	jr nz, .score_check_left
		; update right score
		ldh a, [vScore + RIGHT_INDEX]
		inc a
		ldh [vScore + RIGHT_INDEX], a

		; check win condition
		cp a, SCORE_MAX
		jr nz, .score_right_win
			; TODO right win
			xor a
			ldh [vScore + LEFT_INDEX], a
			ldh [vScore + RIGHT_INDEX], a
		.score_right_win

		; reset ball after right score
		Set16 vBallX, BALL_INITIAL_POS_X
		Set16 vBallY, BALL_INITIAL_POS_Y
		Set16 vBallDirX, BALL_INITIAL_DIR_X
		Set16 vBallDirY, BALL_INITIAL_DIR_Y

		; reset ball speed
		ld a, BALL_INITIAL_SPEED
		ldh [vBallSpeed], a
		ld a, BALL_HIT_COUNTER
		ldh [vBallHitCounter], a

		scf
		ret
	.score_check_left

	; check whether the ball collided with the top or bottom of the pad
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, OAM_X_OFS + PAD_WIDTH
	jr nc, .left_pad_border_collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		ld b, a
		ldh a, [vPadsY + LEFT_INDEX]

		; check if ball is too low
		add a, PAD_HEIGHT - 1
		cp a, b
		jr c, .left_pad_border_collision

		; check if ball is too high
		sub a, (PAD_HEIGHT - 1) + BALL_HEIGHT
		cp a, b
		jr nc, .left_pad_border_collision

		; NOTE: the ball hit the pad

		; determine the relative position of the ball to the pad
		; a = vBallY - (vPadY - 3)
		ld d, a
		inc d
		ld a, b
		sub a, d

		cp a, PAD_HEIGHT + BALL_HEIGHT - 1
		jr nc, .left_hit_bottom
		.left_hit_top
			Set16 vBallDirX, $FFA6
			Set16 vBallDirY, $FFA6
			jr .left_pad_border_collision_done
		.left_hit_bottom
			Set16 vBallDirX, $FFA6
			Set16 vBallDirY, $005A
		.left_pad_border_collision_done

		scf
		ret
	.left_pad_border_collision

	rcf
	ret

HandleRightEvents:
	; return early if the ball is not going left
	ldh a, [vBallDirX + REAL_INTEGER_PART]
	bit 7, a
	rcf
	ret nz

	; check whether the ball hit the pad
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, OAM_X_OFS + SCRN_X - PAD_WIDTH - BALL_WIDTH
	jr nz, .right_pad_collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		ld b, a
		ldh a, [vPadsY + RIGHT_INDEX]

		; check if ball is too low
		add a, PAD_HEIGHT - 1
		cp a, b
		jr c, .right_pad_collision

		; check if ball is too high
		sub a, (PAD_HEIGHT - 1) + BALL_HEIGHT
		cp a, b
		jr nc, .right_pad_collision

		; NOTE: the ball hit the pad

		; determine the relative position of the ball to the pad
		; a = vBallY - (vPadY - 3)
		ld d, a
		inc d
		ld a, b
		sub a, d

		; get a pointer to the new direction entries
		; hl = direction_table_right + (4 * a)
		add a, a
		add a, a
		ld h, 0
		ld l, a
		ld de, direction_table_right
		add hl, de

		; update the direction
		ld a, [hli]
		ldh [vBallDirX + REAL_FRACTION_PART], a
		ld a, [hli]
		ldh [vBallDirX + REAL_INTEGER_PART], a
		ld a, [hli]
		ldh [vBallDirY + REAL_FRACTION_PART], a
		ld a, [hli]
		ldh [vBallDirY + REAL_INTEGER_PART], a

		; update ball speed
		call UpdateBallSpeed

		scf
		ret
	.right_pad_collision

	; check whether the ball reached the goal
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, SCRN_X + OAM_X_OFS
	jr nz, .score_check_right
		; update left score
		ldh a, [vScore + LEFT_INDEX]
		inc a
		ldh [vScore + LEFT_INDEX], a

		; check win condition
		cp a, SCORE_MAX
		jr nz, .score_left_win
			; TODO right win
			xor a
			ldh [vScore + LEFT_INDEX], a
			ldh [vScore + RIGHT_INDEX], a
		.score_left_win

		; reset ball after left score
		Set16 vBallX, BALL_INITIAL_POS_X
		Set16 vBallY, BALL_INITIAL_POS_Y
		Set16 vBallDirX, -BALL_INITIAL_DIR_X
		Set16 vBallDirY, -BALL_INITIAL_DIR_Y

		; reset ball speed
		ld a, BALL_INITIAL_SPEED
		ldh [vBallSpeed], a
		ld a, BALL_HIT_COUNTER
		ldh [vBallHitCounter], a

		scf
		ret
	.score_check_right

	; check whether the ball collided with the top or bottom of the pad
	ldh a, [vBallX + REAL_INTEGER_PART]
	cp a, OAM_X_OFS + SCRN_X - PAD_WIDTH - BALL_WIDTH + 1
	jr c, .right_pad_border_collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		ld b, a
		ldh a, [vPadsY + RIGHT_INDEX]

		; check if ball is too low
		add a, PAD_HEIGHT - 1
		cp a, b
		jr c, .right_pad_border_collision

		; check if ball is too high
		sub a, (PAD_HEIGHT - 1) + BALL_HEIGHT
		cp a, b
		jr nc, .right_pad_border_collision

		; NOTE: the ball hit the pad

		; determine the relative position of the ball to the pad
		; a = vBallY - (vPadY - 3)
		ld d, a
		inc d
		ld a, b
		sub a, d

		cp a, PAD_HEIGHT + BALL_HEIGHT - 1
		jr nc, .right_hit_bottom
		.right_hit_top
			Set16 vBallDirX, $005A
			Set16 vBallDirY, $FFA6
			jr .right_pad_border_collision_done
		.right_hit_bottom
			Set16 vBallDirX, $005A
			Set16 vBallDirY, $005A
		.right_pad_border_collision_done

		scf
		ret
	.right_pad_border_collision

	rcf
	ret

UpdateBall:
	; update ball
	ldh a, [vBallSpeed]
	ld c, a
	.ball_update
		push bc

		; move the ball
		Add16 vBallX, vBallDirX
		Add16 vBallY, vBallDirY

		call HandleBallWallCollision
		call HandleLeftEvents
		; right checks can be skipped if at least one left checks succeeded
		jr c, .skip_right_events
		call HandleRightEvents
		.skip_right_events

		pop bc
		dec c
		jp nz, .ball_update

	ret

_Game_Update:
	call UpdatePads
	call UpdateBall
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; update the game graphics
; must be used during vblank
_Game_UpdateGraphics:
	; update ball sprite
	ldh a, [vBallX + REAL_INTEGER_PART]
	ld [vBallOam + OAMA_X], a
	ldh a, [vBallY + REAL_INTEGER_PART]
	ld [vBallOam + OAMA_Y], a

	; update left pad sprite
	ldh a, [vPadsY + LEFT_INDEX]
	ld [vLeftPadTopOam + OAMA_Y], a
	add a, 8
	ld [vLeftPadBottomOam + OAMA_Y], a

	; update right pad sprite
	ldh a, [vPadsY + RIGHT_INDEX]
	ld [vRightPadTopOam + OAMA_Y], a
	add a, 8
	ld [vRightPadBottomOam + OAMA_Y], a

	ret

