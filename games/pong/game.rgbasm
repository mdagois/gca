include "data.rgbinc"
include "memory.rgbinc"

export _Game_Initialize, _Game_Update, _Game_UpdateGraphics

section "game", rom0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def REAL_FRACTION_PART	equ (0)
def REAL_INTEGER_PART	equ (1)

; set the 16-bit number at address \1 to value \2
macro Set16
	ld a, low(\2)
	ldh [\1 + REAL_FRACTION_PART], a
	ld a, high(\2)
	ldh [\1 + REAL_INTEGER_PART], a
endm

; perform a 16-bit add for numbers at addresses \1 and \2
; the result is stored back at address \1
macro Add16
	ldh a, [\1 + REAL_FRACTION_PART]
	ld b, a
	ldh a, [\2 + REAL_FRACTION_PART]
	add a, b
	ldh [\1 + REAL_FRACTION_PART], a

	ldh a, [\1 + REAL_INTEGER_PART]
	ld b, a
	ldh a, [\2 + REAL_INTEGER_PART]
	adc a, b
	ldh [\1 + REAL_INTEGER_PART], a
endm

; negate the 16-bit number at address \1
macro Negate16
	ldh a, [\1 + REAL_FRACTION_PART]
	xor a, $FF
	ld l, a
	ldh a, [\1 + REAL_INTEGER_PART]
	xor a, $FF
	ld h, a

	ld d, 0
	ld e, 1
	add hl, de

	ld a, l
	ldh [\1 + REAL_FRACTION_PART], a
	ld a, h
	ldh [\1 + REAL_INTEGER_PART], a
endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ResetScore:
	xor a
	ldh [vScore + 0], a
	ldh [vScore + 1], a
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def BALL_INITIAL_SPEED		equ (1)
def BALL_INITIAL_POS_X		equ (((SCRN_X + OAM_X_OFS) / 2 + 2) << 8)
def BALL_INITIAL_POS_Y		equ (((SCRN_Y + OAM_Y_OFS) / 2 - 2) << 8)
def BALL_INITIAL_DIR_X		equ ($0080)
def BALL_INITIAL_DIR_Y		equ ($0080)

_Game_Initialize:
	call ResetScore

	; set sprite tile IDs
	copy [vBallOam + OAMA_TILEID], TILE_ID_BALL
	ld a, TILE_ID_PADS
	ld [vLeftPadTopOam + OAMA_TILEID], a
	inc a
	ld [vLeftPadBottomOam + OAMA_TILEID], a
	inc a
	ld [vRightPadTopOam + OAMA_TILEID], a
	inc a
	ld [vRightPadBottomOam + OAMA_TILEID], a

	; set ball sprite initial positions
	Set16 vBallX, BALL_INITIAL_POS_X
	Set16 vBallY, BALL_INITIAL_POS_Y

	; set pad fixed position
	ld a, OAM_X_OFS
	ld [vLeftPadTopOam + OAMA_X], a
	ld [vLeftPadBottomOam + OAMA_X], a
	ld a, SCRN_X
	ld [vRightPadTopOam + OAMA_X], a
	ld [vRightPadBottomOam + OAMA_X], a

	; set pad variable positions
	ld a, ((SCRN_Y + OAM_Y_OFS) / 2) - 8
	ldh [vLeftPadY], a
	ldh [vRightPadY], a

	; set initial ball dynamics
	Set16 vBallDirX, BALL_INITIAL_DIR_X
	Set16 vBallDirY, BALL_INITIAL_DIR_Y
	ld a, BALL_INITIAL_SPEED
	ldh [vBallSpeed], a

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

def WALL_HEIGHT			equ (8)
def PAD_HEIGHT			equ (16)
def BALL_WIDTH			equ (4)
def BALL_HEIGHT			equ (4)

def PAD_MIN_Y			equ (OAM_Y_OFS + WALL_HEIGHT)
def PAD_MAX_Y			equ (SCRN_Y + OAM_Y_OFS - WALL_HEIGHT - PAD_HEIGHT)

def BALL_MIN_Y			equ (OAM_Y_OFS + WALL_HEIGHT)
def BALL_MAX_Y			equ (SCRN_Y + OAM_Y_OFS - WALL_HEIGHT - BALL_HEIGHT)

_Game_Update:
	; move and apply constraint to left pad
	PadInput_TestHeld vPadInput, PADF_UP
	jr nz, .left_up
		ldh a, [vLeftPadY]
		dec a
		cp a, PAD_MIN_Y
		jr nc, .left_underflow
			ld a, PAD_MIN_Y
		.left_underflow
		ldh [vLeftPadY], a
	.left_up
	PadInput_TestHeld vPadInput, PADF_DOWN
	jr nz, .left_down
		ldh a, [vLeftPadY]
		inc a
		cp a, PAD_MAX_Y
		jr c, .left_overflow
			ld a, PAD_MAX_Y
		.left_overflow
		ldh [vLeftPadY], a
	.left_down

if def(DEBUG_CONTROL_RIGHT_PAD)
	; move and apply constraint to right pad
	PadInput_TestHeld vPadInput, PADF_LEFT
	jr nz, .right_up
		ldh a, [vRightPadY]
		dec a
		cp a, PAD_MIN_Y
		jr nc, .right_underflow
			ld a, PAD_MIN_Y
		.right_underflow
		ldh [vRightPadY], a
	.right_up
	PadInput_TestHeld vPadInput, PADF_RIGHT
	jr nz, .right_down
		ldh a, [vRightPadY]
		inc a
		cp a, PAD_MAX_Y
		jr c, .right_overflow
			ld a, PAD_MAX_Y
		.right_overflow
		ldh [vRightPadY], a
	.right_down
endc

	; update ball
	ldh a, [vBallSpeed]
	ld c, a
	.ball_update
		; move the ball
		Add16 vBallX, vBallDirX
		Add16 vBallY, vBallDirY

		; check for top wall collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		cp a, BALL_MIN_Y
		jr nc, .top_wall_collision
			; apply constraint
			Set16 vBallY, BALL_MIN_Y << 8
			; reverse Y direction
			Negate16 vBallDirY
		.top_wall_collision

		; check for bottom wall collision
		ldh a, [vBallY + REAL_INTEGER_PART]
		cp a, BALL_MAX_Y
		jr c, .bottom_wall_collision
			; apply constraint
			Set16 vBallY, BALL_MAX_Y << 8
			; reverse Y direction
			Negate16 vBallDirY
		.bottom_wall_collision

		; check scoring condition based on ball direction
		ldh a, [vBallDirX + REAL_INTEGER_PART]
		bit 7, a
		ldh a, [vBallX + REAL_INTEGER_PART]
		jr z, .score_check
			; check if left goal reached
			cp a, OAM_X_OFS - BALL_WIDTH
			jr nz, .score_check_left
				; update score
				ldh a, [vScore + 0]
				inc a
				ldh [vScore + 0], a

				; TODO right scoring
				Set16 vBallX, BALL_INITIAL_POS_X
				Set16 vBallY, BALL_INITIAL_POS_Y
				Set16 vBallDirX, BALL_INITIAL_DIR_X

				; check win condition
				cp a, 9
				jr nz, .score_check_left
					; TODO right win

			.score_check_left
			jr .score_check_done
		.score_check
			; check if right goal reached
			cp a, SCRN_X + OAM_X_OFS
			jr nz, .score_check_right
				; update score
				ldh a, [vScore + 1]
				inc a
				ldh [vScore + 1], a

				; TODO left scoring
				Set16 vBallX, ((SCRN_X + OAM_X_OFS) / 2 + 2) << 8
				Set16 vBallY, ((SCRN_Y + OAM_Y_OFS) / 2 - 2) << 8
				Set16 vBallDirX, -BALL_INITIAL_DIR_X

				; check win condition
				cp a, 9
				jr nz, .score_check_right
					; TODO left win
			.score_check_right
		.score_check_done

		dec c
		jp nz, .ball_update

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; update the game graphics
; must be used during vblank
_Game_UpdateGraphics:
	ldh a, [vBallX + REAL_INTEGER_PART]
	ld [vBallOam + OAMA_X], a
	ldh a, [vBallY + REAL_INTEGER_PART]
	ld [vBallOam + OAMA_Y], a

	ldh a, [vLeftPadY]
	ld [vLeftPadTopOam + OAMA_Y], a
	add a, 8
	ld [vLeftPadBottomOam + OAMA_Y], a

	ldh a, [vRightPadY]
	ld [vRightPadTopOam + OAMA_Y], a
	add a, 8
	ld [vRightPadBottomOam + OAMA_Y], a

	ret

